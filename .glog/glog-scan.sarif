{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "4f5d7032-13c7-3697-8516-9f136d0e255b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8a768e57-8ac5-33fc-9ee4-c185f203883c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or that do not provide mechanisms for handling errors. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    int index = std::stoi(strIndex);\n} catch (std::invalid_argument& e) {\n    // Handle exception: input string is not a valid integer\n} catch (std::out_of_range& e) {\n    // Handle exception: integer is out of range\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2bec8f8b-0844-3edb-8e48-8797c81cb5c7",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may refer to overlapping memory areas, which can cause unpredictable results when using memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. Developers should ensure that the source and destination do not overlap and are valid before performing the copy operation.\n\n## In Context Remediation 1\nBefore performing the memory copy, add a check to ensure that the source and destination memory regions do not overlap. If overlap is possible, use a safer function or handle the overlap explicitly:\n\n```cpp\nif ((char*)pTable->amd_ext_ + sizeof(AmdExtTable) <= (char*)&gs_OrigExtApiTable ||\n    (char*)&gs_OrigExtApiTable + sizeof(AmdExtTable) <= (char*)pTable->amd_ext_) {\n    memcpy(static_cast<void*>(pTable->amd_ext_), static_cast<const void*>(&gs_OrigExtApiTable), sizeof(AmdExtTable));\n} else {\n    // Handle overlap case or log an error\n}\n```\nThis ensures that memcpy is only called when the memory regions do not overlap, preventing undefined behavior.\n\n## In Context Remediation 2\nIf overlap between the source and destination is possible or cannot be ruled out, use `memmove` instead of `memcpy`, as `memmove` safely handles overlapping memory regions:\n\n```cpp\nmemmove(static_cast<void*>(pTable->amd_ext_), static_cast<const void*>(&gs_OrigExtApiTable), sizeof(AmdExtTable));\n```\nThis change ensures correct behavior even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c939097e-b2fe-3331-a13b-1f3f68435527",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file name is manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fstream` objects from the C++ Standard Library, which provide a higher level of abstraction and are generally safer.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` object from the C++ Standard Library:\n\n```cpp\n#include <fstream>\n\nstd::ofstream outfile(outname.c_str());\nif (!outfile) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "19ae8875-6496-3ca8-8a4b-12153147ff31",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid duplicating a FILE object (CERT FIO38-C)\" vulnerability in C++ programming language refers to the potential issues that can arise when a FILE object is duplicated. This can lead to data races, data inconsistency, and other unexpected behaviors. This is because the state of a FILE object is not copied when it is duplicated, and the original and duplicate FILE objects share a common file position and status indicators.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid duplicating FILE objects. Instead, create a new FILE object for each file you need to handle. If you need to share a FILE object between different parts of your program, consider using a shared pointer or a similar mechanism to ensure that the FILE object is properly managed and closed when it is no longer needed.\n\n## Source Code Fix Recommendation\n\nWithout the complete source code, it's hard to provide a specific fix. However, here is a general recommendation:\n\n```cpp\n// Incorrect way\nFILE* original = fopen(\"file.txt\", \"r\");\nFILE* duplicate = original;\n\n// Correct way\nFILE* original = fopen(\"file.txt\", \"r\");\nFILE* another = fopen(\"file.txt\", \"r\");\n```\n\nIn the correct way, instead of duplicating the FILE object, we open the file again to create a new FILE object.\n\n## Library Dependencies\n\nThe code example does not provide enough information to determine the library dependencies.\n\n## References\n\n- [CWE-675: Duplicate Operations on Resource](https://cwe.mitre.org/data/definitions/675.html)"
              },
              "properties": {
                "tags": [
                  "DS179924"
                ]
              }
            },
            {
              "id": "09bc0258-ed3e-3ac2-8aeb-bd14ccce0b97",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The risk is supported by dataflow analysis indicating that the destination and source may refer to overlapping memory, which can cause unpredictable results with memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit guards or checks to prevent this issue, and the function verdict confirms the high confidence in this finding. The use of memcpy in such a scenario is unsafe, and remediation is required to ensure memory safety.\n\n## In Context Remediation 1\nTo prevent undefined behavior when the source and destination memory regions may overlap, add a runtime check to ensure they do not overlap before calling memcpy. If overlap is possible, use memmove instead, which is safe for overlapping regions.\n\n```cpp\nif ((static_cast<const char*>(static_cast<const void*>(&gs_OrigCoreApiTable)) + sizeof(CoreApiTable) <= static_cast<const char*>(static_cast<void*>(pTable->core_))) ||\n    (static_cast<const char*>(static_cast<void*>(pTable->core_)) + sizeof(CoreApiTable) <= static_cast<const char*>(static_cast<const void*>(&gs_OrigCoreApiTable)))) {\n    memcpy(static_cast<void*>(pTable->core_), static_cast<const void*>(&gs_OrigCoreApiTable), sizeof(CoreApiTable));\n} else {\n    memmove(static_cast<void*>(pTable->core_), static_cast<const void*>(&gs_OrigCoreApiTable), sizeof(CoreApiTable));\n}\n```\nThis approach ensures that memcpy is only used when it is safe, and memmove is used when overlap is detected.\n\n## In Context Remediation 2\nAlternatively, replace the memcpy call with memmove, which is designed to handle overlapping memory regions safely:\n\n```cpp\nmemmove(static_cast<void*>(pTable->core_), static_cast<const void*>(&gs_OrigCoreApiTable), sizeof(CoreApiTable));\n```\nThis change eliminates the risk of undefined behavior due to overlapping memory regions.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dd5dbf07-c85d-347c-8113-a4aea44cde2a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that the destination buffer may be null at the point of the strncpy call. There are no visible checks in the code to ensure that the destination pointer is valid before the operation. The source is an empty string literal, which is always valid, but the lack of a guard for the destination pointer means that if it is null, the program could crash or behave unpredictably. The risk is further highlighted by the explicit classification and verdict indicating a genuine issue. The probability of this being a false positive is very low, as the absence of a null check for the destination is a clear and common source of runtime errors in C/C++ code.\n\n## In Context Remediation 1\nBefore calling the buffer copy operation, ensure that the destination pointer is not null. This prevents undefined behavior if the destination is accidentally uninitialized or set to null. For example:\n\n```cpp\nif (row.completionSignal != nullptr) {\n    strncpy(row.completionSignal, \"\", 18);\n}\n```\n\nIf the destination is a struct member that should always be valid, review the code to guarantee it is properly initialized before use. If null is a valid state, handle it gracefully to avoid crashes.\n\n\n## In Context Remediation 2\nIf the destination buffer is expected to always be valid and non-null, add an assertion to catch programming errors during development:\n\n```cpp\nassert(row.completionSignal != nullptr);\nstrncpy(row.completionSignal, \"\", 18);\n```\n\nThis will help detect issues early in testing and prevent undefined behavior in production.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "59a7d5fa-45f7-3370-a50f-c9610669cbc1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, the source pointer may be null at runtime, which could also cause a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue.\n\n## In Context Remediation 1\nAdd explicit checks to ensure that the source and destination memory regions do not overlap before calling memcpy. If overlap is possible, use memmove instead, which is safe for overlapping regions.\n\n```cpp\nif ((char*)&gs_OrigExtApiTable + sizeof(AmdExtTable) <= (char*)pTable->amd_ext_ ||\n    (char*)pTable->amd_ext_ + sizeof(AmdExtTable) <= (char*)&gs_OrigExtApiTable) {\n    memcpy(static_cast<void*>(&gs_OrigExtApiTable), static_cast<const void*>(pTable->amd_ext_), sizeof(AmdExtTable));\n} else {\n    // Handle overlap safely\n    memmove(static_cast<void*>(&gs_OrigExtApiTable), static_cast<const void*>(pTable->amd_ext_), sizeof(AmdExtTable));\n}\n```\n\nThis code checks for overlap and only uses memcpy when it is safe. If overlap is detected, it falls back to memmove.\n\n## In Context Remediation 2\nReplace memcpy with memmove to ensure correct behavior even if the source and destination memory regions overlap.\n\n```cpp\nmemmove(static_cast<void*>(&gs_OrigExtApiTable), static_cast<const void*>(pTable->amd_ext_), sizeof(AmdExtTable));\n```\n\nThis change guarantees that the copy will be performed safely regardless of overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2fe5f357-7b6d-3ed6-9f3d-66ea1e135d6e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that the destination buffer may be null, and there are no obvious null pointer checks before the buffer operation. The code copies an empty string into a buffer with a fixed count, but if the destination pointer is null, this will result in a crash or undefined behavior. The source is an empty string literal, which is always valid, but the destination may be null as there is no evidence of a guard or check. The risk is further confirmed by the verdict being marked as genuine. The probability of this being a false positive is very low due to the lack of null checks and the explicit risk classification.\n\n## In Context Remediation 1\nBefore calling the buffer copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the destination is null.\n\n```cpp\nif (row.completionSignal != nullptr) {\n    strncpy(row.completionSignal, \"\", 18);\n}\n```\n\nThis prevents the function from attempting to write to a null pointer, which would otherwise cause a crash or undefined behavior.\n\n## In Context Remediation 2\nIf the destination buffer is expected to always be valid, review the code to ensure it is properly initialized before use. If it can be null, consider allocating memory or handling the null case appropriately.\n\n```cpp\nif (row.completionSignal == nullptr) {\n    row.completionSignal = new char[18]; // or appropriate size\n}\nstrncpy(row.completionSignal, \"\", 18);\n```\n\nThis ensures the destination buffer is always valid before the copy operation.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "ff1851e1-2d93-3181-87aa-5d08a3e84cf8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially lead to a security risk. In C++ programming language, certain functions are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or information disclosure.\n\nIn the provided code snippet, the function `fopen()` is used, which can lead to vulnerabilities if the filename is not properly validated or controlled. An attacker could potentially manipulate the filename to overwrite important files or to create new files in unintended locations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to replace the use of `fopen()` with a safer alternative that includes proper error handling and validation. If `fopen()` must be used, ensure that the filename is properly validated and controlled to prevent potential manipulation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using `fstream` in C++:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(filename.c_str());\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1f0b9279-494c-30e3-b949-b9d828416f8e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the vulnerability sink is the use of the `printf` function, which is a common source of format string vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of using `printf`, consider using `fprintf` or `snprintf` which are safer as they allow specifying the maximum number of characters to be written to the buffer, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `printf` function with a safer alternative. For instance, if you were using `printf` like this:\n\n```cpp\nprintf(\"%s\", user_input);\n```\n\nYou could replace it with `fprintf` or `snprintf` like this:\n\n```cpp\nfprintf(stdout, \"%s\", user_input);\n```\n\nor\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\n```\n\n## Library Dependencies\n\nThe code example does not appear to have any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always ensure to check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7ce4f521-053e-364e-9caf-27383683feca",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis suggests that the destination and source may refer to overlapping memory, which is not allowed by memcpy and can result in unpredictable program behavior. Additionally, the source pointer may be null, which would also cause undefined behavior if dereferenced. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. Developers should ensure that the source and destination do not overlap and that the source pointer is valid before performing the memory copy.\n\n## In Context Remediation 1\nBefore performing the memory copy, add a check to ensure that the source and destination memory regions do not overlap. If overlap is possible, use a temporary buffer or handle the copy in a way that avoids undefined behavior. For example:\n\n```cpp\nif ((char*)pTable->core_ + sizeof(CoreApiTable) <= (char*)&gs_OrigCoreApiTable ||\n    (char*)&gs_OrigCoreApiTable + sizeof(CoreApiTable) <= (char*)pTable->core_) {\n    memcpy(static_cast<void*>(&gs_OrigCoreApiTable), static_cast<const void*>(pTable->core_), sizeof(CoreApiTable));\n} else {\n    // Handle overlap safely, e.g., use a temporary buffer\n    CoreApiTable temp;\n    memcpy(&temp, pTable->core_, sizeof(CoreApiTable));\n    memcpy(&gs_OrigCoreApiTable, &temp, sizeof(CoreApiTable));\n}\n```\nThis ensures that if the regions overlap, the copy is performed safely using a temporary buffer.\n\n## In Context Remediation 2\nAlternatively, if you know that the source and destination may overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory regions safely:\n\n```cpp\nmemmove(static_cast<void*>(&gs_OrigCoreApiTable), static_cast<const void*>(pTable->core_), sizeof(CoreApiTable));\n```\nThis change ensures that the copy is performed correctly even if the memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2830ec25-2f73-3092-8ecb-8f7da27c77e1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string. However, if the string passed to `strlen` is `NULL`, it will cause a segmentation fault, leading to a crash. This is because `strlen` tries to access memory that it shouldn't, which is undefined behavior.\n\nIn the provided code snippet, the ternary operator is used to check if `value_` is `NULL`. If `value_` is `NULL`, it returns `true`. Otherwise, it calls `strlen(value_)`. If `value_` is `NULL`, this will cause a segmentation fault.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always check if a pointer is `NULL` before passing it to `strlen`. If the pointer is `NULL`, you should handle this case appropriately, such as by returning a default value or by throwing an exception.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nvalue_ == NULL || strlen(value_) == 0 ? true : false\n```\n\nIn this version, if `value_` is `NULL`, the condition `value_ == NULL` will be `true`, and the `||` operator will short-circuit, meaning that `strlen(value_)` will not be called. This prevents the segmentation fault.\n\n## Library Dependencies\n\nThe code snippet requires the `cstring` library, which provides the `strlen` function.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "b6f42d50-30b9-3886-bfa0-92b2f2077196",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to ensure that all inputs to these functions are properly validated and sanitized. In the case of `fopen`, it is important to ensure that the filename does not contain any malicious input, such as relative or absolute paths that could lead to unauthorized file access.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `fopen` in C++ is to use the `fstream` library, which provides the `ofstream` class for writing to files. Here is how you can rewrite the code:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(filename_with_tid.c_str());\nif (!file) {\n    // Handle error\n}\n```\n\nThis code will automatically close the file when the `file` object goes out of scope, which is safer and less error-prone than manually closing the file with `fclose`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>` for the `std::ofstream` class.\n\n## OWASP Resources\n\n- [OWASP Proactive Controls](https://owasp.org/www-project-proactive-controls/)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c0575d14-8325-3aff-8871-b8243be955eb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoll()` is used, which converts a string to a long long integer. This function does not perform any error checking, and if the string cannot be converted into a number, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform error checking or are prone to vulnerabilities. Instead, use safer alternatives provided by the C++ Standard Library. In this case, you can use `std::stoll()` function which throws an exception if the conversion cannot be performed.\n\n## Source Code Fix\n\nReplace `atoll(argv[0])` with the following code:\n\n```cpp\n#include <string>\n#include <cstdlib>\n\ntry {\n    long long number = std::stoll(argv[0]);\n} catch (std::invalid_argument const &e) {\n    // Handle the case when the string cannot be converted to a number\n} catch (std::out_of_range const &e) {\n    // Handle the case when the number is out of range for a long long\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`\n- `<cstdlib>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "4f5d7032-13c7-3697-8516-9f136d0e255b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 2602,
                  "startColumn": 4,
                  "endLine": 2602,
                  "endColumn": 11,
                  "charOffset": 119167,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8a768e57-8ac5-33fc-9ee4-c185f203883c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 3005,
                  "startColumn": 24,
                  "endLine": 3005,
                  "endColumn": 28,
                  "charOffset": 133805,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2bec8f8b-0844-3edb-8e48-8797c81cb5c7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 741,
                  "startColumn": 4,
                  "endLine": 743,
                  "endColumn": 30,
                  "charOffset": 29522,
                  "charLength": 133,
                  "snippet": {
                    "text": "memcpy(static_cast<void*>(pTable->amd_ext_),\n           static_cast<const void*>(&gs_OrigExtApiTable),\n           sizeof(AmdExtTable)",
                    "rendered": {
                      "text": "memcpy(static_cast<void*>(pTable->amd_ext_),\n           static_cast<const void*>(&gs_OrigExtApiTable),\n           sizeof(AmdExtTable)",
                      "markdown": "`memcpy(static_cast<void*>(pTable->amd_ext_),\n           static_cast<const void*>(&gs_OrigExtApiTable),\n           sizeof(AmdExtTable)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_tracer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29522,
                        "charLength": 133
                      },
                      "insertedContent": {
                        "text": "memcpy_s(static_cast<void*>(pTable->amd_ext_), <size of static_cast<void*>(pTable->amd_ext_)>, \n           static_cast<const void*>(&gs_OrigExtApiTable), \n           sizeof(AmdExtTable)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c939097e-b2fe-3331-a13b-1f3f68435527",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 2886,
                  "startColumn": 25,
                  "endLine": 2886,
                  "endColumn": 30,
                  "charOffset": 129306,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "19ae8875-6496-3ca8-8a4b-12153147ff31",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid duplicating a FILE object (CERT FIO38-C)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 565,
                  "startColumn": 26,
                  "endLine": 567,
                  "endColumn": 25,
                  "charOffset": 22987,
                  "charLength": 139,
                  "snippet": {
                    "text": "FILE mode we use the raw ticks from the hsa signal, not the clock-translated ticks\n            if (HCC_PROFILE) {\n                start = *",
                    "rendered": {
                      "text": "FILE mode we use the raw ticks from the hsa signal, not the clock-translated ticks\n            if (HCC_PROFILE) {\n                start = *",
                      "markdown": "`FILE mode we use the raw ticks from the hsa signal, not the clock-translated ticks\n            if (HCC_PROFILE) {\n                start = *`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "CERT.FIO38-C",
              "C.DangerousFunctionCall"
            ]
          }
        },
        {
          "ruleId": "09bc0258-ed3e-3ac2-8aeb-bd14ccce0b97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 736,
                  "startColumn": 4,
                  "endLine": 738,
                  "endColumn": 31,
                  "charOffset": 29339,
                  "charLength": 132,
                  "snippet": {
                    "text": "memcpy(static_cast<void*>(pTable->core_),\n           static_cast<const void*>(&gs_OrigCoreApiTable),\n           sizeof(CoreApiTable)",
                    "rendered": {
                      "text": "memcpy(static_cast<void*>(pTable->core_),\n           static_cast<const void*>(&gs_OrigCoreApiTable),\n           sizeof(CoreApiTable)",
                      "markdown": "`memcpy(static_cast<void*>(pTable->core_),\n           static_cast<const void*>(&gs_OrigCoreApiTable),\n           sizeof(CoreApiTable)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_tracer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29339,
                        "charLength": 132
                      },
                      "insertedContent": {
                        "text": "memcpy_s(static_cast<void*>(pTable->core_), <size of static_cast<void*>(pTable->core_)>, \n           static_cast<const void*>(&gs_OrigCoreApiTable), \n           sizeof(CoreApiTable)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dd5dbf07-c85d-347c-8113-a4aea44cde2a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_out_rpd.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 41,
                  "charOffset": 5639,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(row.completionSignal, \"\", 18)",
                    "rendered": {
                      "text": "strncpy(row.completionSignal, \"\", 18)",
                      "markdown": "`strncpy(row.completionSignal, \"\", 18)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_out_rpd.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5639,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(row.completionSignal,  18,  \"\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_out_rpd.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5639,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(row.completionSignal,  \"\",  18)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "59a7d5fa-45f7-3370-a50f-c9610669cbc1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 703,
                  "startColumn": 4,
                  "endLine": 705,
                  "endColumn": 30,
                  "charOffset": 28336,
                  "charLength": 133,
                  "snippet": {
                    "text": "memcpy(static_cast<void*>(&gs_OrigExtApiTable),\n           static_cast<const void*>(pTable->amd_ext_),\n           sizeof(AmdExtTable)",
                    "rendered": {
                      "text": "memcpy(static_cast<void*>(&gs_OrigExtApiTable),\n           static_cast<const void*>(pTable->amd_ext_),\n           sizeof(AmdExtTable)",
                      "markdown": "`memcpy(static_cast<void*>(&gs_OrigExtApiTable),\n           static_cast<const void*>(pTable->amd_ext_),\n           sizeof(AmdExtTable)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_tracer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28336,
                        "charLength": 133
                      },
                      "insertedContent": {
                        "text": "memcpy_s(static_cast<void*>(&gs_OrigExtApiTable), <size of static_cast<void*>(&gs_OrigExtApiTable)>, \n           static_cast<const void*>(pTable->amd_ext_), \n           sizeof(AmdExtTable)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2fe5f357-7b6d-3ed6-9f3d-66ea1e135d6e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_out_rpd.cpp"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 4,
                  "endLine": 155,
                  "endColumn": 41,
                  "charOffset": 4888,
                  "charLength": 37,
                  "snippet": {
                    "text": "strncpy(row.completionSignal, \"\", 18)",
                    "rendered": {
                      "text": "strncpy(row.completionSignal, \"\", 18)",
                      "markdown": "`strncpy(row.completionSignal, \"\", 18)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_out_rpd.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4888,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strcpy_s(row.completionSignal,  18,  \"\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_out_rpd.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4888,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "strlcpy(row.completionSignal,  \"\",  18)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ff1851e1-2d93-3181-87aa-5d08a3e84cf8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_out_printf.cpp"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 13,
                  "endLine": 123,
                  "endColumn": 18,
                  "charOffset": 3111,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1f0b9279-494c-30e3-b949-b9d828416f8e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/flags.h"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 49,
                  "endLine": 80,
                  "endColumn": 55,
                  "charOffset": 3469,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7ce4f521-053e-364e-9caf-27383683feca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_tracer.cpp"
                },
                "region": {
                  "startLine": 698,
                  "startColumn": 4,
                  "endLine": 700,
                  "endColumn": 31,
                  "charOffset": 28156,
                  "charLength": 132,
                  "snippet": {
                    "text": "memcpy(static_cast<void*>(&gs_OrigCoreApiTable),\n           static_cast<const void*>(pTable->core_),\n           sizeof(CoreApiTable)",
                    "rendered": {
                      "text": "memcpy(static_cast<void*>(&gs_OrigCoreApiTable),\n           static_cast<const void*>(pTable->core_),\n           sizeof(CoreApiTable)",
                      "markdown": "`memcpy(static_cast<void*>(&gs_OrigCoreApiTable),\n           static_cast<const void*>(pTable->core_),\n           sizeof(CoreApiTable)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rtg_tracer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28156,
                        "charLength": 132
                      },
                      "insertedContent": {
                        "text": "memcpy_s(static_cast<void*>(&gs_OrigCoreApiTable), <size of static_cast<void*>(&gs_OrigCoreApiTable)>, \n           static_cast<const void*>(pTable->core_), \n           sizeof(CoreApiTable)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2830ec25-2f73-3092-8ecb-8f7da27c77e1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/flags.h"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 50,
                  "endLine": 49,
                  "endColumn": 64,
                  "charOffset": 1507,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(value_)",
                    "rendered": {
                      "text": "strlen(value_)",
                      "markdown": "`strlen(value_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/flags.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1507,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(value_, <size of value_>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/flags.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1507,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(value_, <size of value_>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b6f42d50-30b9-3886-bfa0-92b2f2077196",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rtg_out_printf_lockless.cpp"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 17,
                  "endLine": 78,
                  "endColumn": 22,
                  "charOffset": 2097,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c0575d14-8325-3aff-8871-b8243be955eb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/MetadataTable.cpp"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 16,
                  "endLine": 33,
                  "endColumn": 21,
                  "charOffset": 1492,
                  "charLength": 5,
                  "snippet": {
                    "text": "atoll",
                    "rendered": {
                      "text": "atoll",
                      "markdown": "`atoll`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}